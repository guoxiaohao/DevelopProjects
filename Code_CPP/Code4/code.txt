int nTypes = 0;
	if (argc!=2)
	{
		std::cout << "Default Choose " << nTypes << std::endl;
	}
	else
	{
		char szChoose[128] = { 0 };
		strcpy(szChoose, argv[1]);
		int nVal = atoi(szChoose);

		nTypes = nVal;
		std::cout << "Choose " << nTypes  << std::endl;
	}
    
	char szClientIp[128] = "192.168.10.65";
	int nClientPort = 10006;

	switch (nTypes)
	{
	case 0:
		{
		std::cout << "Client Winsock Sync " << nTypes << std::endl;
		CWinsockSync instanceUse;
		instanceUse.Startup(nClientPort, szClientIp);
		}
		break;
	case 1:



m_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (m_socket == INVALID_SOCKET)
	{
		return;
	}

	sockaddr_in addrs;
	memset(&addrs, 0, sizeof(sockaddr_in));

	addrs.sin_family = AF_INET;
	addrs.sin_port = htons(nPort);
	addrs.sin_addr.S_un.S_addr = inet_addr(szIp);

	while (connect(m_socket, (sockaddr*)&addrs, sizeof(sockaddr)) != 0);

	for (int i = 0; i < 50; i++)
	{
		char szSend[255] = { 0 };
		sprintf(szSend, "%s_%d", "guoxh_type-0", i);
		send(m_socket, szSend, strlen(szSend), 0);

		Sleep(200);
	}
	closesocket(m_socket);

boost::system::error_code ec;
	boost::asio::ip::tcp::socket boost_socket(g_io_service);
	boost::asio::ip::tcp::endpoint endPoint(boost::asio::ip::address::from_string(szIp), nPort);

	while (true)
	{
		boost_socket.connect(endPoint, ec);
		if (ec.value() == 0)
		{
			break;
		}
	}

	if (!boost_socket.is_open())
	{
		std::cout << "Wrong Connect" << std::endl;
		return;
	}

	for (int i = 0; i < 20; i++)
	{
		char szBuffSend[255] = { 0 };
		sprintf(szBuffSend, "%s_%d", "guoxh_type-1", i);
		boost_socket.write_some(boost::asio::buffer(szBuffSend));
		Sleep(200);
	}
	for (int i = 20; i < 40; i++)
	{
		char szBuffSend[255] = { 0 };
		sprintf(szBuffSend, "%s_%d", "guoxy_type-1", i);
		boost_socket.write_some(boost::asio::buffer(szBuffSend));
		Sleep(200);
	}

	boost_socket.close();

sockaddr_in addrListen;
	memset(&addrListen, 0, sizeof(addrListen));
	addrListen.sin_family = AF_INET;
	addrListen.sin_port = htons(nPort);
	addrListen.sin_addr.S_un.S_addr = htonl(INADDR_ANY);

	SOCKET socketListen = socket(AF_INET, SOCK_STREAM, 0);
	if (socketListen==INVALID_SOCKET)
	{
		return;
	}
	bind(socketListen, (sockaddr*)&addrListen, sizeof(addrListen));
	listen(socketListen, 5);
	std::cout << "Begin Listen" << std::endl;

	std::shared_ptr<SOCKET> lpSocketAccept = std::make_shared<SOCKET>();
	
	sockaddr_in addrAccept;
	memset(&addrAccept, 0, sizeof(addrAccept));
	int nLens = sizeof(addrAccept);
	std::cout << "Wait for Client..." << std::endl;
	*lpSocketAccept = accept(socketListen, (sockaddr*)&addrAccept, &nLens);


lpSharedPtrThread = std::make_shared<std::thread>([&]() {
		while (true)
		{
			char szRecvBuff[512] = { 0 };
			int len = recv(*lpSocketAccept, szRecvBuff, sizeof(szRecvBuff) - 1, 0);
			if (len > 0)
			{
				std::cout << szRecvBuff << std::endl;
			}
			else
			{
				std::cout << "Close Connect" << std::endl;
				break;
			}
		}

		std::cout << "Enden" << std::endl;
		m_cv.notify_all();
															});//std::make_shared<std::thread>(std::bind(&CWinSockSync::ThreadRecvData, this, lpSocketAccept));

	//blocks
	std::unique_lock<std::mutex> uniqLock(m_mutex);
	m_cv.wait(uniqLock);

while (true)
	{
		char szRecvBuff[512] = { 0 };
		int len = recv(*lpsocket, szRecvBuff, sizeof(szRecvBuff)-1, 0);
		if (len > 0)
		{
			std::cout << szRecvBuff << std::endl;
		}
		else
		{
			std::cout << "Close Connect" << std::endl;
			break;
		}
	}

	std::cout << "Enden" << std::endl;
	m_cv.notify_all();
}

boost::asio::ip::tcp::endpoint endPoint(boost::asio::ip::tcp::v4(), nPort);
	boost::asio::ip::tcp::acceptor socketListen(g_io_service, endPoint);
	std::cout << "Begin Listen" << std::endl;

	std::shared_ptr<boost::asio::ip::tcp::socket> lpSharedSocketAccept =
		std::make_shared< boost::asio::ip::tcp::socket>(g_io_service);
	std::cout << "Wait for Client..." << std::endl;
	socketListen.accept(*lpSharedSocketAccept);

	lpSharedThread = std::make_shared<std::thread>(&CBoostSync::ClientThread, this, lpSharedSocketAccept);
	
	//blocks
	std::unique_lock<std::mutex> uniqLock(m_mutex);
	m_cv.wait(uniqLock);


boost::system::error_code ec;
	while (true)
	{
		char szRecvBuff[512] = { 0 };
		int len = lpSocketAccept->read_some(boost::asio::buffer(szRecvBuff), ec);
		if (len>0)
		{
			std::cout << szRecvBuff << std::endl;
		}
		else
		{
			std::cout << "Close Connect" << std::endl;
			break;
		}
	}

	std::cout << "Enden" << std::endl;
	m_cv.notify_all();
}

